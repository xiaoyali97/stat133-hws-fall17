---
title: "Lab11"
author: "Xiaoya Li"
date: "November 16, 2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(stringr)
library(dplyr)
```

```{r}
dat <- read.csv('mobile-food-sf.csv', stringsAsFactors = FALSE)
```

###Changing Times
Let's begin processing the values in column starttime. The goal is to obtain new times in 24 hr format. For example, a starting time of 10AM will be transformed to 10:00. Likewise, a starting time of 1PM will be transformed to 13:00.

```{r}
# toy string
time1 <- '10AM'
```

####Function str_sub()
To get the time and period values, you can use str_sub():
```{r}
# hour
str_sub(time1, start = 1, end = 2)

# period
str_sub(time1, start = 3, end = 4)
```

Your turn: What about times where the hour has just one digit? For example: 9AM, or 8AM? Create the following vector times and try to subset the hour and the periods with str_sub()
```{r}
times <- c('12PM', '10AM', '9AM', '8AM')

# subset time
time_sub <- str_sub(times, start = 1, end = nchar(times)- 2)
time_sub

# subset period
period <- str_sub(times, start = -2)
period
```

####Function str_replace()
The tricky part with the vector times is the extraction of the hour. One solution is to "remove" the characters AM or PM from each time. You can do this with the substitution function str_replace():
```{r}
str_replace(times, pattern = 'AM|PM', replacement = '')
```

**Your Turn**\
So far you've managed to get the hour value and the period. Notice that you still need to convert the hours as numeric vectors:

```{r}
hours <- as.numeric(str_replace(times, pattern = 'AM|PM', replacement = ''))
periods <- str_sub(times, start = -2)
```

Transform the hours into 24 hr values. Write R code to create a vector start24 that contains the hour in 24hr scale.
```{r}
start24 <- rep(0, length(times))
for(i in 1:length(times)){
  if(periods[i] == "AM"){
    start24[i] = hours[i]
  }else{
    start24[i] = hours[i] + 12
  }
}
start24
```

Add two columns start and end to the data frame dat, containing the starting and ending hour respectively (columns must be "numeric").
```{r}
to24h <- function(x){
  hours <- as.numeric(str_replace(x, pattern = 'AM|PM', replacement = ''))
  periods <- str_sub(x, start = -2)
  start24 <- rep(0, length(x))
  for(i in 1:length(x)){
    if(periods[i] == "AM"){
      start24[i] = hours[i]
    }else{
      start24[i] = hours[i] + 12
    }
  }
  return(start24)
}
# add 'start' hours
dat$start <- to24h(dat$starttime)

# add 'end' hours
dat$end <- to24h(dat$endtime)

```

With the starting and ending hours, calculate the duration, and add one more column duration to the data frame dat:
```{r}
dat$duration <- dat$end - dat$start
for(i in 1:length(dat$duration)){
  if(dat$duration[i] < 0 ){
    dat$duration[i] = dat$duration[i] + 24
  }
}
```

###Latitude and Longitude Coordinates

```{r}
loc1 <- "(37.7651967350509,-122.416451692902)"
```


The goal is to split Location into latitude and longitude. The first value corresponds to latitude, while the second value corresponds to longitude.


First we need to remove the parenthesis. The issue here is that the characters ( and ) have special meanings; recall they are metacharacters. So you need to escape in R them by pre-appending two backslashes: \\( and \\)
```{r}
# "remove" opening parenthesis 
str_replace(loc1, pattern = '\\(', replacement = '')
```

```{r}
# "remove" closing parenthesis
str_replace(loc1, pattern = '\\)', replacement = '')
```

You can also combine both patterns in a single call. But be careful: str_replace() replaces only the first occurrence of ( or ). However, the location values contain both opening and closing parentheses. To replace them all, you have to use str_replace_all()
```{r}
lat_lon <- str_replace_all(loc1, pattern = '\\(|\\)', replacement = '')
```

Now we need to get rid of the comma ,.\
Instead of replacing the comma, what we need to use is str_split()
```{r}
# string split in stringr
str_split(lat_lon, pattern = ',')
```

#### Manipulating more location values
Let's define a vector with more location values, so we can start generalizing our code:
```{r}
locs <- c(
  "(37.7651967350509,-122.416451692902)",
  "(37.7907890558203,-122.402273431333)",
  "(37.7111991003088,-122.394693339395)",
  "(37.7773000262759,-122.394812784799)",
  NA
)
```

create a list lat_lon containing the latitude and the longitude values of locs
```{r}
lat_lon <- str_replace_all(locs, pattern = '\\(|\\)', replacement = '')
lat_lon <- str_split(lat_lon, pattern = ",")
lat_lon
```

to retrieve the latitude and longitude values, you can use the lapply() function, and then specify an anonymous function to get the first element (for the latitude):
```{r}
lat <- lapply(lat_lon, function(x) x[1])
lat
```

**Your Turn**\

Create a list lon by using lapply() with an anonymous function to extract longitude value (i.e. the second element):
```{r}
lon <- lapply(lat_lon, function(x) x[2])
```

To convert from list to a vector, use unlist()
```{r}
latitute <- as.numeric(unlist(lat))
longitude <- as.numeric(unlist(lon))
```

Add two more columns: lat and lon to the data frame dat
```{r}
dat_lat_lon <- str_replace_all(dat$Location, pattern = '\\(|\\)', replacement = '')
dat_lat_lon <- str_split(dat_lat_lon, pattern = ",")
dat_lat <- lapply(dat_lat_lon, function(x) x[1])
dat_lon <- lapply(dat_lat_lon, function(x) x[2])
dat$lat <- as.numeric(unlist(dat_lat))
dat$lon <- as.numeric(unlist(dat_lon))

```


###Plotting locations on a map
Now that you have two vectors latitude and longitude, and the corrsponding columns lat and lon in the data frame dat, let's try to plot those coordinates on a map.\

A naive option would be to graph the locations with plot():

```{r}
plot(dat$lon, dat$lat, pch = 19, col = "#77777744")
```

Althouth the previous call shows the dots with the right latitude and longitude coordinates, there's no visual cues that let us perceive the information in a geographical way.\


Instead of displaying a naked plot(), we can use the package "RgoogleMaps" which is one the several packages available in R to plot maps.
```{r}
# install.packages("RgoogleMaps")
library(RgoogleMaps)
```

To get a map you use the function GetMap() which requires a center and a zoom specifications. The center is a vector with the latitude and longitude coordinates. The argument zoom refers to the zoom level.

```{r}
# coordinates for center of the map
center <- c(mean(dat$lat, na.rm = TRUE), mean(dat$lon, na.rm = TRUE))

# zoom value
zoom <- min(MaxZoom(range(dat$lat, na.rm = TRUE), 
                    range(dat$lon, na.rm = TRUE)))

# san francisco map
map1 <- GetMap(center=center, zoom=zoom, destfile = "san-francisco.png")
```

The code above downloads a static map from the Google server and saves it in the specified destination file. To make a plot you have to use PlotOnStaticMap()
```{r}
PlotOnStaticMap(map1, dat$lat, dat$lon, col = "#ed4964", pch=20)
```

### Maps with "ggmap"
Another useful package for plotting maps is "ggmap". As you may guess, "ggmap" follows the graphing approach of "ggplot2".\

As usual, you need to install the package:
```{r}
library(ggmap)
```

Because some rows have missing values in the geographical coordinates, we can get rid of them with 'na.omit():

```{r}
# let's get rid of rows with missing values
dat <- na.omit(dat)
```

In order to plot a map with ggmap(), we need to define the region of the map via the function make_bbox():

```{r}
# ggmap typically asks you for a zoom level, 
# but we can try using ggmap's make_bbox function:
sbbox <- make_bbox(lon = dat$lon, lat = dat$lat, f = .1)
sbbox
```

Now that you have the object sbbox, the next step is to get a map with get_map(). This function gets a map from Google by default.

```{r}
# get a 'terrain' map
sf_map <- get_map(location = sbbox, maptype = "terrain", source = "google")
```

Having obtained the sf_map object, we can finally use ggmap() to plot some dots with our lat and lon coordinates:

```{r}
ggmap(sf_map) + 
  geom_point(data = dat, 
             mapping = aes(x = lon, y = lat), 
             color = "red", alpha = 0.2, size = 1)
```

### Let's look for specific types of food

What if you want to identify all locations that have burritos? This is where regular expressions comes very handy. Again, always start small: select the first 10 elements of optionaltext

```{r}
foods <- dat$optionaltext[1:10]
```

Use str_detect() (or equivalently grep()) to match "Burritos" and "burritos".

```{r}
str_detect(foods, pattern = "Burritos|burritos")
```

Try another pattern: e.g. "tacos", or "quesadillas"

```{r}
str_detect(foods, pattern = "tacos|Tacos|quesadillas|Quesadillas")
```

Now create a data frame burritos by subsetting (i.e. filtering) the data frame to get only those rows that match "burritos"

```{r}
burritos <- dat %>% 
  filter(str_detect(optionaltext, pattern = "burritos"))
```

Use the lat and lon corrdinates in burritos to display a map of locations with burritos (see map below).

```{r}
#define the region of the map 
burritosbox <- make_bbox(burritos$lon, burritos$lat, f = 0.1)
burritosbox

#get a map with get_map()
burritosmap <- get_map(location = burritosbox, maptype = "terrain", source = "google")

#use ggmap() to plot some dots 
ggmap(burritosmap) +
  geom_point(data = burritos, 
             mapping = aes(x = lon, y = lat), 
             color = "blue", alpha = 0.2, size = 1)
```

### Practice more Regex patterns

Here's a vector with some character strings:

```{r}
# vector of strings
animals <- c('dog', 'cat', 'bird', 'dolphin', 'lion',
             'zebra', 'tiger', 'wolf', 'whale', 'eagle',
             'pig', 'osprey', 'kangaroo', 'koala')
```

Let's match the pattern dog with grep()
```{r}
grep('dog', animals)
```

To extract the matched pattern, you can use grep() with the argument value = TRUE:
```{r}
grep('dog', animals, value = TRUE)
```

Using "stringr" functions, you can use str_detect() to check if there is a match:
```{r}
str_detect(animals, 'dog')
```

To extract the matched pattern, you use str_extract():
```{r}
str_extract(animals, 'dog')
```

What if you just want to extract the matched pattern and nothing else? Then use logical subsetting:
```{r}
animals[str_detect(animals, 'dog')]
```

**Your turn**\
Use str_extract(), and logical subsetting with str_detect(), to find the names of animals with:
- zero or more o
```{r}
animals[str_detect(animals, "o*")]
```

- zero or one o
```{r}
animals[str_detect(animals, "o?")]
```

- at least 1 o
```{r}
animals[str_detect(animals, "o+")]
```

- exactly 2 o's together
```{r}
animals[str_detect(animals, "o{2}")]
```

- one o, but not two o's together
```{r}
animals[str_detect(animals, "o[^o]")]
```

- two vowels together
```{r}
animals[str_detect(animals, "[aeiou][aeiou]")]
```

- two consonants together
```{r}
animals[str_detect(animals, "[^aeiou][^aeiou]")]
```

- three consonants together
```{r}
animals[str_detect(animals, "[^aeiou]{3}")]
```

- three letters only
```{r}
animals[str_detect(animals, "\\b[a-z]{3}\\b")]
```

- four letters only
```{r}
animals[str_detect(animals, "\\b[a-z]{4}\\b")]
```


#### File Names
Here's another character vector with some file names and their extensions:
```{r}
files <- c('sales1.csv', 'orders.csv', 'sales2.csv',
           'sales3.csv', 'europe.csv', 'usa.csv', 'mex.csv',
           'CA.csv', 'FL.csv', 'NY.csv', 'TX.csv',
           'sales-europe.csv', 'sales-usa.csv', 'sales-mex.csv')
```

**Your turn**
- Find the file names containing numbers
```{r}
files[str_detect(files, pattern = "\\d")]
```

- Find the file names containing no numbers

```{r}
files[str_detect(files, pattern = "^\\D*$")]
```

- Find the file names containing lower case letters

```{r}
files[str_detect(str_sub(files, start = 1, end = nchar(files) - 4), pattern = "[a-z]")]
```

- Find the file names containing upper case letters
```{r}
files[str_detect(str_sub(files, start = 1, end = nchar(files) - 4), pattern = "[A-Z]")]
```

- Find the file names containing a dash
```{r}
files[str_detect(files, pattern = "-")]
```

- Find the file names containing no dash
```{r}
files[str_detect(files, pattern = "^[^-]*$")]
```

- Create a vector of files by replacing the 'csv' extension into 'txt' extension

```{r}
files_txt <- str_replace(files,pattern = "csv", "txt")
files_txt
```

- Separate file name from file extension
```{r}
str_split(files, pattern = "\\.")

```

#### Some Functions
Create a function split_chars() that splits a character string into one single character elements. The output must be a single character vector. 
```{r}
split_chars <- function(x){
  list <- str_split(x,"")
  return(unlist(list))
}
split_chars('Go Bears!')
```

Here's another exmaple, split_chars('Expecto Patronum') should return:
```{r}
split_chars('Expecto Patronum')
```

Write a function reverse_chars() that reverses a string by characters. 

```{r}
reverse_chars <- function(x) {
  letter = split_chars(x)
  reverse_letter = rep("", length(letter))
  for(i in 1:length(letter)){
    reverse_letter[i] = letter[length(letter) + 1 - i]
  }
  return(paste0(reverse_letter, collapse = ""))
}
reverse_chars("gattaca")
```

```{r}
reverse_chars("Lumox Maxima")
```








